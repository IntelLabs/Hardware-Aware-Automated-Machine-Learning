diff --git a/nncf/common/pruning/shape_pruning_processor.py b/nncf/common/pruning/shape_pruning_processor.py
index 9bb099cb..77c77dea 100644
--- a/nncf/common/pruning/shape_pruning_processor.py
+++ b/nncf/common/pruning/shape_pruning_processor.py
@@ -20,7 +20,7 @@ from nncf.common.pruning.mask_propagation import MaskPropagationAlgorithm
 from nncf.common.pruning.structs import PrunedLayerInfoBase
 from nncf.common.pruning.symbolic_mask import SymbolicMask
 from nncf.common.pruning.symbolic_mask import SymbolicMaskProcessor
-from nncf.common.pruning.utils import get_input_masks
+from nncf.common.pruning.utils import get_input_masks, get_input_masks_with_dynamic_inputs
 from nncf.common.pruning.utils import get_next_nodes_of_types
 from nncf.common.pruning.utils import get_output_channels
 from nncf.common.pruning.utils import get_prunable_layers_in_out_channels
@@ -158,10 +158,14 @@ class ShapePruningProcessor:
         return tmp_in_channels, tmp_out_channels
 
     def _get_next_node_sparse_multiplier(
-        self, graph: NNCFGraph, next_node: NNCFNode, cluster: Clusterization[PrunedLayerInfoBase]
+        self, 
+        graph: NNCFGraph, 
+        next_node: NNCFNode, 
+        cluster: Clusterization[PrunedLayerInfoBase], 
+        add_dynamic_inputs: List[str] = None
     ) -> int:
         cluster_nodes_idxs = {node.nncf_node_id for node in cluster.elements}
-        for input_mask in get_input_masks(next_node, graph):
+        for input_mask in get_input_masks_with_dynamic_inputs(next_node, graph, add_dynamic_inputs):
             if not input_mask:
                 continue
             for mask_producer in input_mask.mask_producers:
@@ -171,7 +175,10 @@ class ShapePruningProcessor:
         raise RuntimeError(f"Next node for cluster {cluster.elements} doesn't have closing mask")
 
     def get_next_nodes(
-        self, graph: NNCFGraph, pruning_groups: Clusterization[PrunedLayerInfoBase]
+        self, 
+        graph: NNCFGraph, 
+        pruning_groups: Clusterization[PrunedLayerInfoBase],
+        add_dynamic_inputs: List[str] = None
     ) -> Dict[int, Dict[str, Any]]:
         """
         Finds nodes of `prunable_types` types that receive the output of a pruned cluster as input
@@ -202,7 +209,7 @@ class ShapePruningProcessor:
             next_nodes_cluster = next_nodes_cluster - cluster_nodes
             next_nodes[cluster.id] = []
             for next_node in next_nodes_cluster:
-                sparse_multiplier = self._get_next_node_sparse_multiplier(graph, next_node, cluster)
+                sparse_multiplier = self._get_next_node_sparse_multiplier(graph, next_node, cluster, add_dynamic_inputs)
                 next_nodes[cluster.id].append(
                     {"node_name": next_node.node_name, "sparse_multiplier": sparse_multiplier}
                 )
diff --git a/nncf/common/pruning/utils.py b/nncf/common/pruning/utils.py
index e119d017..10eca744 100644
--- a/nncf/common/pruning/utils.py
+++ b/nncf/common/pruning/utils.py
@@ -373,6 +373,39 @@ def get_input_masks(node: NNCFNode, graph: NNCFGraph) -> List[Optional[NNCFTenso
     return retval
 
 
+def get_input_masks_with_dynamic_inputs(
+    node: NNCFNode, 
+    graph: NNCFGraph, 
+    add_dynamic_inputs: List[str] = None
+) -> List[Optional[NNCFTensor]]:
+    retval = []
+    input_masks = [input_node.attributes['output_mask'] for input_node in graph.get_previous_nodes(node)]
+    if add_dynamic_inputs:
+        if node.node_name in add_dynamic_inputs and any(elem is None for elem in input_masks):
+            nodes_to_check = [node]
+            while any(elem is None for elem in input_masks):
+                previous_nodes = []
+                for check_node in nodes_to_check:
+                    previous_nodes.append(graph.get_previous_nodes(check_node))
+                nodes_to_check.clear()
+                previous_nodes = [item for nodes in previous_nodes for item in nodes]
+                if not previous_nodes:
+                    break
+                for previous in previous_nodes:
+                    if 'output_mask' in previous.attributes:
+                        if previous.attributes['output_mask'] is not None:
+                            input_masks.append(previous.attributes['output_mask'])
+                            input_masks = [i for i in input_masks if i]
+                        else:
+                            nodes_to_check.append(previous)
+                    else:
+                        nodes_to_check.append(previous)
+
+    for input_mask in input_masks:
+        retval.append(input_mask[node.node_name] if isinstance(input_mask, dict) else input_mask)
+    return retval
+
+
 def get_input_channels(node: NNCFNode) -> int:
     """
     Returns count of input channels of an prunable node.
diff --git a/nncf/experimental/torch/nas/bootstrapNAS/elasticity/elastic_width.py b/nncf/experimental/torch/nas/bootstrapNAS/elasticity/elastic_width.py
index fd918a54..5413e307 100644
--- a/nncf/experimental/torch/nas/bootstrapNAS/elasticity/elastic_width.py
+++ b/nncf/experimental/torch/nas/bootstrapNAS/elasticity/elastic_width.py
@@ -532,7 +532,7 @@ class ElasticWidthHandler(SingleElasticityHandler):
         self._shape_pruning_processor = ShapePruningProcessor(
             prunable_types=prunable_types, pruning_operations_metatype=PT_PRUNING_OPERATOR_METATYPES
         )
-        self._next_nodes = self._shape_pruning_processor.get_next_nodes(graph, pruned_module_groups_info)
+        self._next_nodes = self._shape_pruning_processor.get_next_nodes(graph, pruned_module_groups_info, add_dynamic_inputs)
         # Need a copy because it will be used for adding `output_mask`/`input_masks` to nodes that are relevant to
         # Elastic Width only and therefore it should be isolated to not intercept with other algorithms.
         self._propagation_graph = deepcopy(graph)
@@ -685,7 +685,7 @@ class ElasticWidthHandler(SingleElasticityHandler):
                         if not previous_nodes:
                             break
                         for previous in previous_nodes:
-                            if "output_mask" in previous.data:
+                            if "output_mask" in previous.attributes:
                                 if previous.attributes["output_mask"] is not None:
                                     input_masks.append(previous.attributes["output_mask"])
                                     input_masks = [i for i in input_masks if i]
diff --git a/nncf/torch/compression_method_api.py b/nncf/torch/compression_method_api.py
index efbbe8b2..220e2e4e 100644
--- a/nncf/torch/compression_method_api.py
+++ b/nncf/torch/compression_method_api.py
@@ -141,7 +141,8 @@ class PTCompressionAlgorithmBuilder(BaseCompressionAlgorithmBuilder):
         )
 
         layout = self._get_transformation_layout(model)
-        self._handle_frozen_layers(model)
+        # allow frozen layers for LoNAS
+        # self._handle_frozen_layers(model)
         return layout
 
     @abstractmethod
